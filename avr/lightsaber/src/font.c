#include <stdbool.h>
#include <stdlib.h>
#include <stdio.h>
#include <avr/io.h>
#include <avr/interrupt.h>
#include <util/delay.h>
#include "font.h"

/* private data */
#define PWM_PERIOD (F_CPU / 2 / PWM_FREQ)
#define PWM_REST   (PWM_LUT[128])

// generated by pwm_lut.py
static const uint16_t PWM_LUT[256] = {
      0,   2,   3,   5,   6,   8,   9,  11,  13,  14,  16,  17,  19,  20,  22,  24,
     25,  27,  28,  30,  31,  33,  35,  36,  38,  39,  41,  42,  44,  45,  47,  49,
     50,  52,  53,  55,  56,  58,  60,  61,  63,  64,  66,  67,  69,  71,  72,  74,
     75,  77,  78,  80,  82,  83,  85,  86,  88,  89,  91,  93,  94,  96,  97,  99,
    100, 102, 104, 105, 107, 108, 110, 111, 113, 115, 116, 118, 119, 121, 122, 124,
    125, 127, 129, 130, 132, 133, 135, 136, 138, 140, 141, 143, 144, 146, 147, 149,
    151, 152, 154, 155, 157, 158, 160, 162, 163, 165, 166, 168, 169, 171, 173, 174,
    176, 177, 179, 180, 182, 184, 185, 187, 188, 190, 191, 193, 195, 196, 198, 199,
    201, 202, 204, 205, 207, 209, 210, 212, 213, 215, 216, 218, 220, 221, 223, 224,
    226, 227, 229, 231, 232, 234, 235, 237, 238, 240, 242, 243, 245, 246, 248, 249,
    251, 253, 254, 256, 257, 259, 260, 262, 264, 265, 267, 268, 270, 271, 273, 275,
    276, 278, 279, 281, 282, 284, 285, 287, 289, 290, 292, 293, 295, 296, 298, 300,
    301, 303, 304, 306, 307, 309, 311, 312, 314, 315, 317, 318, 320, 322, 323, 325,
    326, 328, 329, 331, 333, 334, 336, 337, 339, 340, 342, 344, 345, 347, 348, 350,
    351, 353, 355, 356, 358, 359, 361, 362, 364, 365, 367, 369, 370, 372, 373, 375,
    376, 378, 380, 381, 383, 384, 386, 387, 389, 391, 392, 394, 395, 397, 398, 400,
};

static struct {
    void (*ticker)();
    uint16_t ticker_ctr;
    uint16_t ticker_per;

    uint32_t font_addr[8];
    uint8_t num_fonts;
    uint8_t font_idx;

    uint8_t r, g, b;
    uint8_t fast, slow;
    uint8_t num_swing;
    uint8_t num_clash;

    uint32_t boot;
    uint32_t hum;
    uint32_t off;
    uint32_t on;
    uint32_t swing[10];
    uint32_t clash[10];

    bool new;
    bool chain_hum;
    uint32_t addr;

    bool done;
    uint32_t len;
} font_data;

/* private helpers */
static inline void spi_write(uint8_t b) {
    SPI0.DATA = b;
}

static inline void spi_write_blocking(uint8_t b) {
    spi_write(b);
    while (!(SPI0.INTFLAGS & SPI_RXCIF_bm));
}

static inline uint8_t spi_read() {
    uint8_t b = SPI0.DATA;
    spi_write(0xFF); // dummy byte
    return b;
}

static inline uint8_t spi_read_blocking() {
    while (!(SPI0.INTFLAGS & SPI_RXCIF_bm));
    return spi_read();
}

static inline void flash_start_read(uint32_t addr) {
    PORTC.DIRSET = PIN2_bm;
    spi_write_blocking(0x03);
    spi_write_blocking(addr >> 16);
    spi_write_blocking(addr >> 8);
    spi_write_blocking(addr >> 0);
    spi_write(0xFF); // send initial dummy byte
}

static inline void flash_end_read() {
    while (!(SPI0.INTFLAGS & SPI_RXCIF_bm));
    PORTC.DIRCLR = PIN2_bm;
}

static inline uint8_t flash_read_byte() {
    return spi_read_blocking();
}

static inline uint32_t flash_read_word() {
    uint32_t b   = flash_read_byte();
    b = (b << 8) | flash_read_byte();
    b = (b << 8) | flash_read_byte();
    b = (b << 8) | flash_read_byte();
    return b;
}

static inline void audio_enable() {
    PORTB.OUTSET = PIN5_bm;
}

static inline void audio_disable() {
    PORTB.OUTCLR = PIN5_bm;
}

ISR(TCA0_OVF_vect) {
    TCA0.SINGLE.INTFLAGS = 0x01; // clear OVF

    uint16_t duty = PWM_REST;
    if (font_data.new) {
        audio_enable();
        flash_end_read();
        flash_start_read(font_data.addr);
        font_data.len  = flash_read_word();
        font_data.new  = false;
        font_data.done = false;
    } else if (font_data.len) {
        font_data.len--;
        duty = PWM_LUT[spi_read()];
    } else if (font_data.chain_hum) {
        flash_end_read();
        flash_start_read(font_data.hum);
        font_data.len  = flash_read_word();
        font_data.done = true;
        duty = PWM_LUT[spi_read_blocking()];
    } else {
        audio_disable();
        flash_end_read();
        font_data.done = true;
    }
    TCA0.SINGLE.CMP1BUF = duty;

    font_data.ticker_ctr++;
    if (font_data.ticker_ctr >= font_data.ticker_per) {
        font_data.ticker_ctr = 0;
        font_data.ticker();
    }
}

/* public functions */
void font_init(void (*callback)(), uint16_t freq) {
    // setup SPI0
    PORTC.DIRCLR = PIN2_bm; // open-drain CS
    PORTC.OUTCLR = PIN2_bm;

    SPI0.CTRLA   = SPI_PRESC_DIV4_gc | SPI_MASTER_bm | SPI_CLK2X_bm; // MSB first, master, 10MHz
    SPI0.CTRLB   = SPI_MODE_0_gc | SPI_SSD_bm; // no buffer, disable CS, MODE0
    SPI0.INTCTRL = 0x00; // no IRQs
    SPI0.CTRLA  |= SPI_ENABLE_bm;

    // setup TCA0 for WO1 on PB4
    TCA0.SINGLE.CTRLA   = TCA_SINGLE_CLKSEL_DIV2_gc | TCA_SINGLE_ENABLE_bm;
    TCA0.SINGLE.CTRLB   = TCA_SINGLE_WGMODE_SINGLESLOPE_gc | TCA_SINGLE_CMP1EN_bm;
    TCA0.SINGLE.INTCTRL = TCA_SINGLE_OVF_bm;
    TCA0.SINGLE.PER     = PWM_PERIOD - 1;
    TCA0.SINGLE.CMP1BUF = PWM_REST;
    PORTMUX.CTRLC       = PORTMUX_TCA01_bm; // remap WO1 => PB4
    PORTB.DIRSET        = PIN5_bm; // PWM pin on STPIN250 enables audio

    font_data.ticker     = callback;
    font_data.ticker_ctr = 0;
    font_data.ticker_per = PWM_FREQ / freq;
    srand(69);
    font_wake();
}

void font_sleep() {
    TCA0.SINGLE.CTRLA &= ~TCA_SINGLE_ENABLE_bm;
    PORTA.DIRCLR = PIN1_bm | PIN3_bm;
    PORTB.DIRCLR = PIN4_bm;
}

void font_wake() {
    PORTA.DIRSET = PIN1_bm | PIN3_bm;
    PORTB.DIRSET = PIN4_bm;

    flash_start_read(0x000000);
    if (flash_read_word() != PWM_FREQ) {
        printf("sample frequency mismatch!\r\n");
    }
    font_data.num_fonts = 8;
    for (uint8_t i = 0; i < 8; i++) {
        font_data.font_addr[i] = flash_read_word();
        if (font_data.font_addr[i] == 0xFFFFFFFF) {
            font_data.num_fonts = i;
            break;
        }
    }
    flash_end_read();

    if (font_data.font_idx >= font_data.num_fonts) {
        font_data.font_idx = 0;
    }
    font_select(font_data.font_idx);
}

void font_select(uint8_t i) {
    TCA0.SINGLE.CTRLA &= ~TCA_SINGLE_ENABLE_bm;
    flash_start_read(font_data.font_addr[i]);
    font_data.r    = flash_read_byte();
    font_data.g    = flash_read_byte();
    font_data.b    = flash_read_byte();
    uint8_t s      = flash_read_byte();
    font_data.fast = (s >> 0) & 0x0F;
    font_data.slow = (s >> 4) & 0x0F;
    font_data.boot = flash_read_word();
    font_data.hum  = flash_read_word();
    font_data.off  = flash_read_word();
    font_data.on   = flash_read_word();
    font_data.num_swing = 10;
    font_data.num_clash = 10;
    for (int i = 0; i < 10; i++) {
        font_data.swing[i] = flash_read_word();
        if (font_data.swing[i] == 0xFFFFFFFF) {
            font_data.num_swing = i;
            break;
        }
    }
    for (int i = 0; i < 10; i++) {
        font_data.clash[i] = flash_read_word();
        if (font_data.clash[i] == 0xFFFFFFFF) {
            font_data.num_clash = i;
            break;
        }
    }
    flash_end_read();
    TCA0.SINGLE.CTRLA |= TCA_SINGLE_ENABLE_bm;
}

uint8_t font_num()     { return font_data.num_fonts; }
uint8_t font_idx()     { return font_data.font_idx;  }
uint8_t font_r()       { return font_data.r; }
uint8_t font_g()       { return font_data.g; }
uint8_t font_b()       { return font_data.b; }
uint8_t font_upscale() { return font_data.slow; }
uint8_t font_speedup() { return font_data.fast; }

void font_play(font_type_t type) {
    switch (type) {
        case FONT_TYPE_BOOT:
            font_data.addr      = font_data.boot;
            font_data.chain_hum = false;
            break;

        case FONT_TYPE_OFF:
            font_data.addr      = font_data.off;
            font_data.chain_hum = false;
            break;

        case FONT_TYPE_ON:
            font_data.addr      = font_data.on;
            font_data.chain_hum = true;
            break;

        case FONT_TYPE_SWING:
            font_data.addr      = font_data.swing[rand() % font_data.num_swing];
            font_data.chain_hum = true;
            break;

        case FONT_TYPE_CLASH:
            font_data.addr      = font_data.clash[rand() % font_data.num_clash];
            font_data.chain_hum = true;
            break;

        default:
            font_data.addr      = font_data.boot;
            font_data.chain_hum = false;
            break;
    }
    font_data.new = true;
}

bool font_done() {
    return font_data.done;
}
