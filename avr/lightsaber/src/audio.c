#include <stdbool.h>
#include <stdio.h>
#include <avr/io.h>
#include <avr/interrupt.h>
#include "audio.h"

/* private data */
#define PWM_PERIOD (F_CPU / 2 / PWM_FREQ)
#define PWM_REST   (PWM_LUT[128])

// generated by pwm_lut.py
const uint16_t PWM_LUT[256] = {
      0,   2,   3,   5,   6,   8,   9,  11,  13,  14,  16,  17,  19,  20,  22,  24,
     25,  27,  28,  30,  31,  33,  35,  36,  38,  39,  41,  42,  44,  45,  47,  49,
     50,  52,  53,  55,  56,  58,  60,  61,  63,  64,  66,  67,  69,  71,  72,  74,
     75,  77,  78,  80,  82,  83,  85,  86,  88,  89,  91,  93,  94,  96,  97,  99,
    100, 102, 104, 105, 107, 108, 110, 111, 113, 115, 116, 118, 119, 121, 122, 124,
    125, 127, 129, 130, 132, 133, 135, 136, 138, 140, 141, 143, 144, 146, 147, 149,
    151, 152, 154, 155, 157, 158, 160, 162, 163, 165, 166, 168, 169, 171, 173, 174,
    176, 177, 179, 180, 182, 184, 185, 187, 188, 190, 191, 193, 195, 196, 198, 199,
    201, 202, 204, 205, 207, 209, 210, 212, 213, 215, 216, 218, 220, 221, 223, 224,
    226, 227, 229, 231, 232, 234, 235, 237, 238, 240, 242, 243, 245, 246, 248, 249,
    251, 253, 254, 256, 257, 259, 260, 262, 264, 265, 267, 268, 270, 271, 273, 275,
    276, 278, 279, 281, 282, 284, 285, 287, 289, 290, 292, 293, 295, 296, 298, 300,
    301, 303, 304, 306, 307, 309, 311, 312, 314, 315, 317, 318, 320, 322, 323, 325,
    326, 328, 329, 331, 333, 334, 336, 337, 339, 340, 342, 344, 345, 347, 348, 350,
    351, 353, 355, 356, 358, 359, 361, 362, 364, 365, 367, 369, 370, 372, 373, 375,
    376, 378, 380, 381, 383, 384, 386, 387, 389, 391, 392, 394, 395, 397, 398, 400,
};

struct {
    audio_ticker_F ticker;

    uint8_t r, g, b;
    uint8_t fast, slow;

    uint32_t boot;
    uint32_t hum;
    uint32_t off;
    uint32_t on;
    uint32_t swing[10];
    uint32_t clash[10];

    // TODO update
    bool new;
    uint32_t addr;
    uint32_t len;
} audio_data;

/* private helpers */
// low-level flash helpers
static inline void audio_write_byte_blocking(uint8_t b) {
    SPI0.DATA = b;
    while (!(SPI0.INTFLAGS & SPI_RXCIF_bm));
}

static inline void audio_start_read(uint32_t addr) {
    PORTC.DIRSET = PIN2_bm;
    audio_write_byte_blocking(0x03);
    audio_write_byte_blocking(addr >> 16);
    audio_write_byte_blocking(addr >> 8);
    audio_write_byte_blocking(addr >> 0);
    SPI0.DATA = 0xFF; // send initial dummy byte
}

static inline void audio_end_read() {
    while (!(SPI0.INTFLAGS & SPI_RXCIF_bm));
    PORTC.DIRCLR = PIN2_bm;
}

static inline uint8_t audio_read_byte() {
    uint8_t b = SPI0.DATA;
    SPI0.DATA = 0xFF; // dummy byte
    return b;
}

static inline uint8_t audio_read_byte_blocking() {
    while (!(SPI0.INTFLAGS & SPI_RXCIF_bm));
    return audio_read_byte();
}

// LightFS helpers
static inline uint32_t audio_fs_read_word() {
    uint32_t b = audio_read_byte_blocking();
    b = (b << 8) | audio_read_byte_blocking();
    b = (b << 8) | audio_read_byte_blocking();
    b = (b << 8) | audio_read_byte_blocking();
    return b;
}

ISR(TCA0_OVF_vect) {
    // 25kHz ISR
    TCA0.SINGLE.INTFLAGS = 0x01; // clear OVF

    // TODO add loop support
    if (audio_data.new) {
        TCA0.SINGLE.CMP1BUF = PWM_REST;
        PORTB.OUTSET = PIN5_bm;
        audio_end_read();
        audio_start_read(audio_data.addr);
        audio_data.len = audio_fs_read_word();
        audio_data.new = false;
    } else if (audio_data.len) {
        TCA0.SINGLE.CMP1BUF = PWM_LUT[audio_read_byte()];
        audio_data.len--;
    } else {
        TCA0.SINGLE.CMP1BUF = PWM_REST;
        PORTB.OUTCLR = PIN5_bm;
        audio_end_read();
    }
    audio_data.ticker();
}

/* public functions */
void audio_init(audio_ticker_F ticker) {
    PORTA.DIRSET = PIN1_bm | PIN3_bm;
    PORTC.DIRCLR = PIN2_bm; // open-drain CS
    PORTC.OUTCLR = PIN2_bm;

    SPI0.CTRLA   = SPI_PRESC_DIV4_gc | SPI_MASTER_bm | SPI_CLK2X_bm; // MSB first, master, 10MHz
    SPI0.CTRLB   = SPI_MODE_0_gc | SPI_SSD_bm; // no buffer, disable CS, MODE0
    SPI0.INTCTRL = 0x00; // no IRQs
    SPI0.CTRLA  |= SPI_ENABLE_bm;

    // read font 0
    audio_start_read(0x000000);
    if (audio_fs_read_word() != PWM_FREQ) {
        printf("sample frequency mismatch!\r\n");
    }
    uint32_t font_addr = audio_fs_read_word();
    audio_end_read();

    audio_start_read(font_addr);
    audio_data.r    = audio_read_byte_blocking();
    audio_data.g    = audio_read_byte_blocking();
    audio_data.b    = audio_read_byte_blocking();
    uint8_t s       = audio_read_byte_blocking();
    audio_data.fast = (s >> 0) & 0x0F;
    audio_data.slow = (s >> 4) & 0x0F;
    audio_data.boot = audio_fs_read_word();
    audio_data.hum  = audio_fs_read_word();
    audio_data.off  = audio_fs_read_word();
    audio_data.on   = audio_fs_read_word();
    for (int i = 0; i < 10; i++) {
        audio_data.swing[i] = audio_fs_read_word();
    }
    for (int i = 0; i < 10; i++) {
        audio_data.clash[i] = audio_fs_read_word();
    }
    audio_end_read();

    // setup TCA0 for WO1
    TCA0.SINGLE.CTRLA   = TCA_SINGLE_CLKSEL_DIV2_gc | TCA_SINGLE_ENABLE_bm;
    TCA0.SINGLE.CTRLB   = TCA_SINGLE_WGMODE_SINGLESLOPE_gc | TCA_SINGLE_CMP1EN_bm;
    TCA0.SINGLE.INTCTRL = TCA_SINGLE_OVF_bm;
    TCA0.SINGLE.PER     = PWM_PERIOD - 1;
    TCA0.SINGLE.CMP1BUF = PWM_REST;
    
    // WO2 => PB4
    PORTB.DIRSET  = PIN4_bm;
    PORTMUX.CTRLC = PORTMUX_TCA01_bm;

    // set PWM pin on STPIN250 to enable audio
    PORTB.DIRSET = PIN5_bm;
    PORTB.OUTSET = PIN5_bm;

    audio_data.ticker = ticker;

    // TODO update and remove
    audio_data.addr = audio_data.on;
    audio_data.new  = true;
}
